package org.healthystyle.health.repository.diet;

import java.time.LocalDate;
import java.util.List;
import java.util.Set;

import org.healthystyle.health.model.diet.FoodValue;
import org.healthystyle.health.model.diet.Value;
import org.healthystyle.health.repository.result.AvgStatistic;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import jakarta.persistence.EntityManager;

@Repository
public interface FoodValueRepository extends JpaRepository<FoodValue, Long>, CustomFoodValueRepository {
	@Query("SELECT fv FROM FoodValue fv INNER JOIN fv.food f INNER JOIN f.health h WHERE f.id = :foodId AND h.id = :healthId")
	Page<FoodValue> findByFood(Long foodId, Long healthId, Pageable pageable);

	@Query("SELECT fv FROM FoodValue fv INNER JOIN fv.nutritionValue nv INNER JOIN nv.convertType ct WHERE nv.id = :nutritionValueId AND (TYPE(ct) = IntegerNumber AND CAST(fv.value AS integer) <= CAST(:value AS integer) OR TYPE(ct) = FloatNumber AND CAST(fv.value AS FLOAT) <= CAST(:value AS FLOAT))")
	Page<FoodValue> findByValueAndNutritionValue(String value, Long nutritionValueId, Pageable pageable);

	@Query("SELECT SUM(CASE WHEN TYPE(ct) = IntegerNumber THEN CAST(fv.value AS INTEGER) WHEN TYPE(ct) = FloatNumber THEN CAST(fv.value AS FLOAT) END) FROM FoodValue fv INNER JOIN fv.nutritionValue nv INNER JOIN nv.convertType ct INNER JOIN fv.food f WHERE nv.id = :nutritionValueId AND f.id IN :foodIds")
	Integer findSumByFoodsAndNutritionValue(List<Long> foodIds, Long nutritionValueId);

// meal food weight!!!!//	@Query(value = "SELECT DATE_TRUNC('week', CASE WHEN m.day IS NOT NULL THEN weeks + interval '1' day * m.day ELSE weeks END) AS week, AVG(CASE WHEN TYPE(ctmf) = IntegerNumber THEN CAST(mf.weight AS INTEGER) / 100 * (CASE WHEN TYPE(ct) = IntegerNumber THEN CAST(fv.value AS INTEGER) WHEN TYPE(ct) = FloatNumber THEN CAST(fv.value AS FLOAT)) WHEN TYPE(ct) = FloatNumber) THEN CAST(value AS FLOAT) / 100 * (CASE WHEN TYPE(ct) = IntegerNumber THEN CAST(fv.value AS INTEGER) WHEN TYPE(ct) = FloatNumber THEN CAST(fv.value AS FLOAT)) END) FROM GENERATE_SERIES(?2::date, ?3::date, interval '1' week) AS weeks LEFT JOIN diet d ON (d.start, d.end) overlaps (weeks, interval '1 week') INNER JOIN health h ON h.id = d.health_id INNER JOIN meal m ON m.diet_id = h.id AND d.start <= (weeks + interval '1' day * m.day) AND d.end >= (weeks + interval '1' day * m.day) INNER JOIN meal_food mf ON mf.meal_id = m.id INNER JOIN convertType ctmf ON ctmf.id = mf.convert_type_id INNER JOIN food f ON f.id = mf.food_id INNER JOIN food_value fv ON fv.food_id = f.id INNER JOIN nutrition_value nv ON nv.id = fv.nutrition_value_id INNER JOIN convert_type ct ON nv.convert_type_id = ct.id WHERE nv.id = ?0 AND h.id = ?1 GROUP BY date_trunc('week', CASE WHEN m.day IS NOT NULL THEN weeks + interval '1' day * m.day ELSE weeks END) ORDER BY date_trunc('week', case when m.day is not null then weeks + interval '1' day * m.day else weeks end)", nativeQuery = true)
	@Query(value = "SELECT date_trunc('week', CASE WHEN m.day IS NOT NULL THEN date_trunc('week', weeks) + interval '1' day * m.day ELSE date_trunc('week', weeks) END) AS week, TO_CHAR(AVG((CASE WHEN ct.dtype = 'int_numb' THEN CAST(fv.value AS INTEGER) WHEN ct.dtype = 'float_numb' THEN CAST(fv.value AS FLOAT) END) * mf.weight / 100), 'FM999999990.09') AS avgValue FROM GENERATE_SERIES(CAST(?3 AS TIMESTAMP), CAST(?4 AS TIMESTAMP), interval '1 week') AS weeks LEFT JOIN diet d ON (d.start, d.finish) overlaps (weeks, interval '1 week') INNER JOIN meal m ON m.diet_id = d.id AND d.start <= case when m.day is not null then date_trunc('week', weeks) + interval '1' day * m.day else date_trunc('week', weeks) end AND d.finish >= case when m.day is not null then date_trunc('week', weeks) + interval '1' day * m.day else date_trunc('week', weeks) end INNER JOIN meal_food mf ON mf.meal_id = m.id INNER JOIN food f ON f.id = mf.food_id INNER JOIN food_value fv ON fv.food_id = f.id INNER JOIN nutrition_value nv ON nv.id = fv.nutrition_value_id INNER JOIN convert_type ct ON nv.convert_type_id = ct.id WHERE nv.id = ?1 AND d.health_id = ?2 GROUP BY date_trunc('week', CASE WHEN m.day IS NOT NULL THEN date_trunc('week', weeks) + interval '1' day * m.day ELSE (date_trunc('week', weeks)) END) ORDER BY date_trunc('week', case when m.day is not null then date_trunc('week', weeks) + interval '1' day * m.day else date_trunc('week', weeks) end)", nativeQuery = true)
	Page<Object[]> findAvgRangeWeek(Long nutritionValueId, Long healthId, LocalDate start, LocalDate to,
			Pageable pageable);

	// meal food weight!!!!//	@Query(value = "SELECT DATE_TRUNC('month', CASE WHEN m.day IS NOT NULL THEN weeks + interval '1' day * m.day ELSE weeks END) AS month, AVG(CASE WHEN TYPE(ctmf) = IntegerNumber THEN CAST(mf.weight AS INTEGER) / 100 * (CASE WHEN TYPE(ct) = IntegerNumber THEN CAST(fv.value AS INTEGER) WHEN TYPE(ct) = FloatNumber THEN CAST(fv.value AS FLOAT)) WHEN TYPE(ct) = FloatNumber) THEN CAST(value AS FLOAT) / 100 * (CASE WHEN TYPE(ct) = IntegerNumber THEN CAST(fv.value AS INTEGER) WHEN TYPE(ct) = FloatNumber THEN CAST(fv.value AS FLOAT)) END) FROM GENERATE_SERIES(?2::date, ?3::date, interval '1' week) AS weeks LEFT JOIN diet d ON (d.start, d.end) overlaps (weeks, interval '1 week') INNER JOIN health h ON h.id = d.health_id INNER JOIN meal m ON m.diet_id = h.id AND d.start <= (weeks + interval '1' day * m.day) AND d.end >= (weeks + interval '1' day * m.day) INNER JOIN meal_food mf ON mf.meal_id = m.id INNER JOIN convertType ctmf ON ctmf.id = mf.convert_type_id INNER JOIN food f ON f.id = mf.food_id INNER JOIN food_value fv ON fv.food_id = f.id INNER JOIN nutrition_value nv ON nv.id = fv.nutrition_value_id INNER JOIN convert_type ct ON nv.convert_type_id = ct.id WHERE nv.id = ?0 AND h.id = ?1 AND date_trunc('month', case when m.day is not null then weeks + interval '1' day * m.day else weeks end) >= date_trunc('month', ?2::date) AND date_trunc('month', case when m.day is not null then weeks + interval '1' day * m.day else weeks end) <= date_trunc('month', ?3::date) GROUP BY date_trunc('month', CASE WHEN m.day IS NOT NULL THEN weeks + interval '1' day * m.day ELSE weeks END) ORDER BY date_trunc('month', case when m.day is not null then weeks + interval '1' day * m.day else weeks end)", nativeQuery = true)
	@Query(value = "SELECT date_trunc('month', CASE WHEN m.day IS NOT NULL THEN date_trunc('week', weeks) + interval '1' day * m.day ELSE date_trunc('week', weeks) END) AS month, TO_CHAR(AVG((CASE WHEN ct.dtype = 'int_numb' THEN CAST(fv.value AS INTEGER) WHEN ct.dtype = 'float_numb' THEN CAST(fv.value AS FLOAT) END) * mf.weight / 100), 'FM999999990.09') AS avgValue FROM GENERATE_SERIES(CAST(?3 AS TIMESTAMP), CAST(?4 AS TIMESTAMP), interval '1 week') AS weeks LEFT JOIN diet d ON (d.start, d.finish) overlaps (weeks, interval '1 week') INNER JOIN meal m ON m.diet_id = d.id AND d.start <= case when m.day is not null then date_trunc('week', weeks) + interval '1' day * m.day else date_trunc('week', weeks) end AND d.finish >= case when m.day is not null then date_trunc('week', weeks) + interval '1' day * m.day else date_trunc('week', weeks) end INNER JOIN meal_food mf ON mf.meal_id = m.id INNER JOIN food f ON f.id = mf.food_id INNER JOIN food_value fv ON fv.food_id = f.id INNER JOIN nutrition_value nv ON nv.id = fv.nutrition_value_id INNER JOIN convert_type ct ON nv.convert_type_id = ct.id WHERE nv.id = ?1 AND d.health_id = ?2 GROUP BY date_trunc('month', CASE WHEN m.day IS NOT NULL THEN date_trunc('week', weeks) + interval '1' day * m.day ELSE (date_trunc('week', weeks)) END) ORDER BY date_trunc('month', case when m.day is not null then date_trunc('week', weeks) + interval '1' day * m.day else date_trunc('week', weeks) end)", nativeQuery = true)
	Page<Object[]> findAvgRangeMonth(Long nutritionValueId, Long healthId, LocalDate start, LocalDate to, 
			Pageable pageable);
	
	// meal food weight!!!!//	@Query(value = "SELECT DATE_TRUNC('year', CASE WHEN m.day IS NOT NULL THEN weeks + interval '1' day * m.day ELSE weeks END) AS year, AVG(CASE WHEN TYPE(ctmf) = IntegerNumber THEN CAST(mf.weight AS INTEGER) / 100 * (CASE WHEN TYPE(ct) = IntegerNumber THEN CAST(fv.value AS INTEGER) WHEN TYPE(ct) = FloatNumber THEN CAST(fv.value AS FLOAT)) WHEN TYPE(ct) = FloatNumber) THEN CAST(value AS FLOAT) / 100 * (CASE WHEN TYPE(ct) = IntegerNumber THEN CAST(fv.value AS INTEGER) WHEN TYPE(ct) = FloatNumber THEN CAST(fv.value AS FLOAT)) END) FROM GENERATE_SERIES(?2::date, ?3::date, interval '1' week) AS weeks LEFT JOIN diet d ON (d.start, d.end) overlaps (weeks, interval '1 week') INNER JOIN health h ON h.id = d.health_id INNER JOIN meal m ON m.diet_id = h.id AND d.start <= (weeks + interval '1' day * m.day) AND d.end >= (weeks + interval '1' day * m.day) INNER JOIN meal_food mf ON mf.meal_id = m.id INNER JOIN convertType ctmf ON ctmf.id = mf.convert_type_id INNER JOIN food f ON f.id = mf.food_id INNER JOIN food_value fv ON fv.food_id = f.id INNER JOIN nutrition_value nv ON nv.id = fv.nutrition_value_id INNER JOIN convert_type ct ON nv.convert_type_id = ct.id WHERE nv.id = ?0 AND h.id = ?1 AND date_trunc('year', case when m.day is not null then weeks + interval '1' day * m.day else weeks end) >= date_trunc('month', ?2::date) AND date_trunc('year', case when m.day is not null then weeks + interval '1' day * m.day else weeks end) <= date_trunc('year', ?3::date) GROUP BY date_trunc('year', CASE WHEN m.day IS NOT NULL THEN weeks + interval '1' day * m.day ELSE weeks END) ORDER BY date_trunc('year', case when m.day is not null then weeks + interval '1' day * m.day else weeks end)", nativeQuery = true)
	@Query(value = "SELECT date_trunc('year', CASE WHEN m.day IS NOT NULL THEN date_trunc('week', weeks) + interval '1' day * m.day ELSE date_trunc('week', weeks) END) AS year, TO_CHAR(AVG((CASE WHEN ct.dtype = 'int_numb' THEN CAST(fv.value AS INTEGER) WHEN ct.dtype = 'float_numb' THEN CAST(fv.value AS FLOAT) END) * mf.weight / 100), 'FM999999990.09') AS avgValue FROM GENERATE_SERIES(CAST(?3 AS TIMESTAMP), CAST(?4 AS TIMESTAMP), interval '1 week') AS weeks LEFT JOIN diet d ON (d.start, d.finish) overlaps (weeks, interval '1 week') INNER JOIN meal m ON m.diet_id = d.id AND d.start <= case when m.day is not null then date_trunc('week', weeks) + interval '1' day * m.day else date_trunc('week', weeks) end AND d.finish >= case when m.day is not null then date_trunc('week', weeks) + interval '1' day * m.day else date_trunc('week', weeks) end INNER JOIN meal_food mf ON mf.meal_id = m.id INNER JOIN food f ON f.id = mf.food_id INNER JOIN food_value fv ON fv.food_id = f.id INNER JOIN nutrition_value nv ON nv.id = fv.nutrition_value_id INNER JOIN convert_type ct ON nv.convert_type_id = ct.id WHERE nv.id = ?1 AND d.health_id = ?2 GROUP BY date_trunc('year', CASE WHEN m.day IS NOT NULL THEN date_trunc('week', weeks) + interval '1' day * m.day ELSE (date_trunc('week', weeks)) END) ORDER BY date_trunc('year', case when m.day is not null then date_trunc('week', weeks) + interval '1' day * m.day else date_trunc('week', weeks) end)", nativeQuery = true)
	Page<Object[]> findAvgRangeYear(Long nutritionValueId, Long healthId, LocalDate start, LocalDate to,
			Pageable pageable);
	
	@Query("SELECT EXISTS (SELECT fv FROM FoodValue fv INNER JOIN fv.food f INNER JOIN fv.nutritionValue nv WHERE f.id = :foodId AND nv.value = :value)")
	boolean existsByFoodAndNutritionValue(Long foodId, Value value);
	
	@Query("DELETE FROM FoodValue fv WHERE fv.id IN :ids")
	void deleteByIds(Set<Long> ids);
}
